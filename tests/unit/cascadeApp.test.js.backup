/**
 * CascadeApp Unit Tests
 * Testing individual methods and components in isolation
 */

import { jest } from '@jest/globals';

// Import test utilities first
import { mockGlobalDOM } from '../mocks/domMock.js';
import { setupTestStorage } from '../mocks/storageMock.js';
import { createEventBusMock, eventAssertions } from '../mocks/eventBusMock.js';
import { 
  createTestTask,
  createTestBoard,
  todoTask,
  doingTask,
  doneTask,
  TASK_COLLECTIONS,
  BOARD_COLLECTIONS
} from '../fixtures/index.js';

describe('CascadeApp Unit Tests', () => {
  let mockDocument;
  let mockEventBus;
  
  // Mock modules
  let mockAppState;
  let mockStorage;
  let mockDomManager;
  let mockAccessibility;
  let mockSettingsManager;
  let mockDebugLog;
  let mockModels;
  
  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup DOM environment
    mockDocument = mockGlobalDOM();
    
    // Setup storage
    setupTestStorage('singleBoard');
    
    // Create fresh event bus mock
    mockEventBus = createEventBusMock();
    
    // Create module mocks
    mockAppState = {
      get: jest.fn((key) => {
        switch(key) {
          case 'tasks': return [];
          case 'filter': return 'all';
          case 'boards': return [];
          case 'currentBoardId': return 'mock-board-id';
          default: return undefined;
        }
      }),
      setState: jest.fn(),
      subscribe: jest.fn(),
      getCurrentBoard: jest.fn(() => ({
        id: 'mock-board-id',
        name: 'Mock Board',
        tasks: []
      })),
      getActiveBoards: jest.fn(() => []),
      addBoard: jest.fn(),
      setCurrentBoard: jest.fn(),
      updateBoard: jest.fn(),
      removeBoard: jest.fn(),
      getHistory: jest.fn(() => []),
      canUndo: jest.fn(() => false),
      canRedo: jest.fn(() => false),
      undo: jest.fn(),
      redo: jest.fn()
    };

    mockStorage = {
      load: jest.fn(),
      save: jest.fn(),
      exportData: jest.fn(),
      importData: jest.fn(),
      clearAll: jest.fn(),
      getStorageInfo: jest.fn()
    };

    mockDomManager = {
      init: jest.fn(),
      renderTasks: jest.fn(),
      renderBoardSelector: jest.fn(),
      showModal: jest.fn(),
      clearTaskInput: jest.fn(),
      showToast: jest.fn(),
      sanitizeHTML: jest.fn(text => text),
      getElementById: jest.fn(),
      addEventListener: jest.fn(),
      updateTaskElement: jest.fn(),
      removeTaskElement: jest.fn()
    };

    mockAccessibility = {
      init: jest.fn(),
      updateTaskCounts: jest.fn(),
      announceTaskAction: jest.fn(),
      setAriaLabel: jest.fn(),
      updateScreenReader: jest.fn()
    };

    mockSettingsManager = {
      loadSettings: jest.fn(),
      applyTheme: jest.fn(),
      get: jest.fn(),
      set: jest.fn(),
      getAutoArchiveConfig: jest.fn(() => ({ enabled: false, days: 30 }))
    };

    mockDebugLog = {
      log: jest.fn(),
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      group: jest.fn(),
      groupEnd: jest.fn()
    };

    mockModels = {
      Board: jest.fn(),
      Task: jest.fn(),
      createBoard: jest.fn((data = {}) => ({
        id: data.id || 'mock-board-id',
        name: data.name || 'Mock Board',
        description: data.description || '',
        color: data.color || '#6750a4',
        tasks: data.tasks || [],
        createdDate: data.createdDate || new Date().toISOString(),
        lastModified: data.lastModified || new Date().toISOString(),
        isArchived: data.isArchived || false,
        isDefault: data.isDefault || false
      })),
      createTask: jest.fn((data = {}) => ({
        id: data.id || 'mock-task-id',
        text: data.text || 'Mock Task',
        status: data.status || 'todo',
        createdDate: data.createdDate || new Date().toISOString().split('T')[0],
        lastModified: data.lastModified || new Date().toISOString()
      })),
      validateTask: jest.fn(() => true),
      validateBoard: jest.fn(() => true)
    };


    // Mock module imports
    jest.unstable_mockModule('scripts/modules/eventBus.js', () => ({
      default: mockEventBus
    }));

    jest.unstable_mockModule('scripts/modules/state.js', () => ({
      default: mockAppState
    }));

    jest.unstable_mockModule('scripts/modules/storage.js', () => ({
      default: mockStorage
    }));

    jest.unstable_mockModule('scripts/modules/dom.js', () => ({
      default: mockDomManager
    }));

    jest.unstable_mockModule('scripts/modules/accessibility.js', () => ({
      default: mockAccessibility
    }));

    jest.unstable_mockModule('scripts/modules/settings.js', () => ({
      settingsManager: mockSettingsManager,
      debugLog: mockDebugLog
    }));

    jest.unstable_mockModule('scripts/modules/models.js', () => mockModels);

  });

  describe('Initialization', () => {
    test('should initialize app with all modules', async () => {
      // Arrange & Act
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      const app = new CascadeApp(); // init() is called automatically in constructor

      // Assert - App should initialize successfully
      expect(app).toBeDefined();
      expect(app.state).toBeDefined();
      expect(app.storage).toBeDefined();
      expect(app.dom).toBeDefined();
      
      // Since we're using real modules (not mocks), we verify the app structure instead
      expect(typeof app.init).toBe('function');
      expect(typeof app.render).toBe('function');
    });

    test('should handle initialization failures gracefully', async () => {
      // Arrange
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      const initError = new Error('Init failed');
      mockDomManager.init.mockRejectedValue(initError);

      // Act
      const app = new CascadeApp();
      await app.init();

      // Assert
      expect(mockDebugLog.error).toHaveBeenCalledWith('âŒ App initialization failed:', initError);
      expect(mockEventBus.emit).toHaveBeenCalledWith('app:error', { error: initError });
    });

    test('should set up event listeners during initialization', async () => {
      // Arrange
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      const app = new CascadeApp();

      // Act
      await app.init();

      // Assert
      expect(mockEventBus.on).toHaveBeenCalledWith('task:created', expect.any(Function));
      expect(mockEventBus.on).toHaveBeenCalledWith('task:updated', expect.any(Function));
      expect(mockEventBus.on).toHaveBeenCalledWith('board:switched', expect.any(Function));
    });
  });

  describe('Task Management Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('validateTaskInput', () => {
      test('should validate task text correctly', () => {
        // Valid inputs
        expect(app.validateTaskInput('Valid task')).toBe(true);
        expect(app.validateTaskInput('A')).toBe(true);
        expect(app.validateTaskInput('x'.repeat(200))).toBe(true);

        // Invalid inputs
        expect(app.validateTaskInput('')).toBe(false);
        expect(app.validateTaskInput('   ')).toBe(false);
        expect(app.validateTaskInput(null)).toBe(false);
        expect(app.validateTaskInput(undefined)).toBe(false);
        expect(app.validateTaskInput('x'.repeat(201))).toBe(false);
      });

      test('should log validation errors', () => {
        // Act
        app.validateTaskInput('');

        // Assert
        expect(mockDebugLog.warn).toHaveBeenCalledWith('âš ï¸ Task validation failed: empty text');
      });
    });

    describe('sanitizeTaskText', () => {
      test('should sanitize task text properly', () => {
        expect(app.sanitizeTaskText('  Valid task  ')).toBe('Valid task');
        expect(app.sanitizeTaskText('<script>alert("xss")</script>')).toBe('alert("xss")');
        expect(app.sanitizeTaskText('Task with\nnewlines')).toBe('Task with newlines');
      });
    });

    describe('findTaskById', () => {
      test('should find task by ID', () => {
        // Arrange
        const tasks = TASK_COLLECTIONS.workflow;
        mockAppState.get.mockReturnValue(tasks);

        // Act
        const result = app.findTaskById(todoTask.id);

        // Assert
        expect(result).toEqual(todoTask);
      });

      test('should return null for non-existent task', () => {
        // Arrange
        mockAppState.get.mockReturnValue([]);

        // Act
        const result = app.findTaskById('non-existent');

        // Assert
        expect(result).toBeNull();
      });
    });

    describe('getTasksByStatus', () => {
      test('should filter tasks by status', () => {
        // Arrange
        const tasks = TASK_COLLECTIONS.multipleByStatus;
        mockAppState.get.mockReturnValue(tasks);

        // Act
        const todoTasks = app.getTasksByStatus('todo');
        const doneTasks = app.getTasksByStatus('done');

        // Assert
        expect(todoTasks).toHaveLength(2);
        expect(doneTasks).toHaveLength(2);
        expect(todoTasks.every(t => t.status === 'todo')).toBe(true);
        expect(doneTasks.every(t => t.status === 'done')).toBe(true);
      });
    });

    describe('getTaskStatistics', () => {
      test('should calculate task statistics correctly', () => {
        // Arrange
        const tasks = TASK_COLLECTIONS.multipleByStatus;
        mockAppState.get.mockReturnValue(tasks);

        // Act
        const stats = app.getTaskStatistics();

        // Assert
        expect(stats).toEqual({
          total: 6,
          todo: 2,
          doing: 2,
          done: 2,
          completionRate: 2/6
        });
      });

      test('should handle empty task list', () => {
        // Arrange
        mockAppState.get.mockReturnValue([]);

        // Act
        const stats = app.getTaskStatistics();

        // Assert
        expect(stats).toEqual({
          total: 0,
          todo: 0,
          doing: 0,
          done: 0,
          completionRate: 0
        });
      });
    });
  });

  describe('Board Management Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('validateBoardInput', () => {
      test('should validate board data correctly', () => {
        // Valid inputs
        expect(app.validateBoardInput({ name: 'Valid Board', description: '' })).toBe(true);
        expect(app.validateBoardInput({ name: 'A', description: 'Test' })).toBe(true);

        // Invalid inputs
        expect(app.validateBoardInput({ name: '', description: '' })).toBe(false);
        expect(app.validateBoardInput({ name: '   ', description: '' })).toBe(false);
        expect(app.validateBoardInput({ name: 'x'.repeat(51), description: '' })).toBe(false);
        expect(app.validateBoardInput(null)).toBe(false);
      });
    });

    describe('findBoardById', () => {
      test('should find board by ID', () => {
        // Arrange
        const boards = BOARD_COLLECTIONS.multiple;
        mockAppState.getActiveBoards.mockReturnValue(boards);

        // Act
        const result = app.findBoardById('board-work');

        // Assert
        expect(result).toEqual(boards.find(b => b.id === 'board-work'));
      });

      test('should return null for non-existent board', () => {
        // Arrange
        mockAppState.getActiveBoards.mockReturnValue([]);

        // Act
        const result = app.findBoardById('non-existent');

        // Assert
        expect(result).toBeNull();
      });
    });

    describe('getBoardStatistics', () => {
      test('should calculate board statistics', async () => {
        // Arrange
        const board = createTestBoard({
          tasks: TASK_COLLECTIONS.multipleByStatus
        });
        mockAppState.get.mockReturnValue([board]);

        // Act
        const stats = await app.getBoardStatistics({ boardId: board.id });

        // Assert
        expect(stats).toEqual({
          boardId: board.id,
          boardName: board.name,
          totalTasks: 6,
          completedTasks: 2,
          activeTasks: 4,
          completionRate: expect.any(Number),
          averageCompletionTime: expect.any(Number),
          lastActivity: expect.any(String)
        });
      });
    });

    describe('canDeleteBoard', () => {
      test('should prevent deletion of default board', () => {
        // Arrange
        const defaultBoard = createTestBoard({ isDefault: true });

        // Act & Assert
        expect(app.canDeleteBoard(defaultBoard)).toBe(false);
      });

      test('should prevent deletion when only one board exists', () => {
        // Arrange
        const board = createTestBoard();
        mockAppState.getActiveBoards.mockReturnValue([board]);

        // Act & Assert
        expect(app.canDeleteBoard(board)).toBe(false);
      });

      test('should allow deletion of non-default board when multiple exist', () => {
        // Arrange
        const board = createTestBoard({ isDefault: false });
        mockAppState.getActiveBoards.mockReturnValue(BOARD_COLLECTIONS.multiple);

        // Act & Assert
        expect(app.canDeleteBoard(board)).toBe(true);
      });
    });
  });

  describe('Event Handling Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('setupEventListeners', () => {
      test('should register all required event listeners', () => {
        // Act
        app.setupEventListeners();

        // Assert
        const expectedEvents = [
          'task:created', 'task:updated', 'task:deleted', 'task:moved',
          'board:created', 'board:updated', 'board:deleted', 'board:switched',
          'data:loaded', 'data:saved', 'app:error'
        ];

        expectedEvents.forEach(event => {
          expect(mockEventBus.on).toHaveBeenCalledWith(event, expect.any(Function));
        });
      });
    });

    describe('handleTaskEvent', () => {
      test('should handle task creation events', () => {
        // Arrange
        const task = createTestTask();

        // Act
        app.handleTaskEvent('created', { task });

        // Assert
        expect(mockDomManager.renderTasks).toHaveBeenCalled();
        expect(mockAccessibility.announceTaskAction).toHaveBeenCalledWith('created', task);
      });

      test('should handle task update events', () => {
        // Arrange
        const task = createTestTask();

        // Act
        app.handleTaskEvent('updated', { task });

        // Assert
        expect(mockDomManager.updateTaskElement).toHaveBeenCalledWith(task);
        expect(mockAccessibility.announceTaskAction).toHaveBeenCalledWith('updated', task);
      });

      test('should handle task deletion events', () => {
        // Arrange
        const taskId = 'deleted-task';

        // Act
        app.handleTaskEvent('deleted', { taskId });

        // Assert
        expect(mockDomManager.removeTaskElement).toHaveBeenCalledWith(taskId);
        expect(mockAccessibility.announceTaskAction).toHaveBeenCalledWith('deleted', { id: taskId });
      });
    });

    describe('handleBoardEvent', () => {
      test('should handle board switch events', () => {
        // Arrange
        const board = createTestBoard();

        // Act
        app.handleBoardEvent('switched', { board });

        // Assert
        expect(mockDomManager.renderBoardSelector).toHaveBeenCalled();
        expect(mockDomManager.renderTasks).toHaveBeenCalled();
        expect(mockAccessibility.updateTaskCounts).toHaveBeenCalled();
      });

      test('should handle board creation events', () => {
        // Arrange
        const board = createTestBoard();

        // Act
        app.handleBoardEvent('created', { board });

        // Assert
        expect(mockDomManager.renderBoardSelector).toHaveBeenCalled();
        expect(mockDomManager.showToast).toHaveBeenCalledWith(`Board "${board.name}" created`);
      });
    });
  });

  describe('Utility Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('generateId', () => {
      test('should generate unique IDs', () => {
        const id1 = app.generateId();
        const id2 = app.generateId();

        expect(id1).toBeTruthy();
        expect(id2).toBeTruthy();
        expect(id1).not.toBe(id2);
        expect(typeof id1).toBe('string');
      });

      test('should generate IDs with prefix when provided', () => {
        const id = app.generateId('task');
        expect(id).toMatch(/^task-/);
      });
    });

    describe('formatDate', () => {
      test('should format dates correctly', () => {
        const date = new Date('2025-01-01T10:00:00.000Z');
        const formatted = app.formatDate(date);

        expect(formatted).toBe('2025-01-01');
      });

      test('should handle date strings', () => {
        const formatted = app.formatDate('2025-01-01T10:00:00.000Z');
        expect(formatted).toBe('2025-01-01');
      });
    });

    describe('formatDateTime', () => {
      test('should format date and time correctly', () => {
        const date = new Date('2025-01-01T10:30:00.000Z');
        const formatted = app.formatDateTime(date);

        expect(formatted).toMatch(/2025-01-01.*10:30/);
      });
    });

    describe('debounce', () => {
      test('should debounce function calls', (done) => {
        const mockFn = jest.fn();
        const debouncedFn = app.debounce(mockFn, 100);

        debouncedFn();
        debouncedFn();
        debouncedFn();

        setTimeout(() => {
          expect(mockFn).toHaveBeenCalledTimes(1);
          done();
        }, 150);
      });
    });

    describe('throttle', () => {
      test('should throttle function calls', (done) => {
        const mockFn = jest.fn();
        const throttledFn = app.throttle(mockFn, 100);

        throttledFn();
        throttledFn();
        throttledFn();

        expect(mockFn).toHaveBeenCalledTimes(1);

        setTimeout(() => {
          throttledFn();
          expect(mockFn).toHaveBeenCalledTimes(2);
          done();
        }, 150);
      });
    });
  });

  describe('State Management Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('getCurrentState', () => {
      test('should return current application state', () => {
        // Arrange
        const expectedState = {
          boards: BOARD_COLLECTIONS.multiple,
          currentBoardId: 'board-work',
          tasks: TASK_COLLECTIONS.workflow,
          filter: 'all'
        };
        mockAppState.get.mockImplementation((key) => expectedState[key]);

        // Act
        const state = app.getCurrentState();

        // Assert
        expect(state).toEqual(expectedState);
      });
    });

    describe('updateState', () => {
      test('should update application state', () => {
        // Arrange
        const updates = { filter: 'done' };

        // Act
        app.updateState(updates);

        // Assert
        expect(mockAppState.setState).toHaveBeenCalledWith(updates);
      });
    });

    describe('canUndo/canRedo', () => {
      test('should check undo/redo availability', () => {
        mockAppState.canUndo.mockReturnValue(true);
        mockAppState.canRedo.mockReturnValue(false);

        expect(app.canUndo()).toBe(true);
        expect(app.canRedo()).toBe(false);
      });
    });

    describe('undo/redo', () => {
      test('should perform undo/redo operations', () => {
        app.undo();
        app.redo();

        expect(mockAppState.undo).toHaveBeenCalled();
        expect(mockAppState.redo).toHaveBeenCalled();
      });
    });
  });

  describe('Error Handling Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('handleError', () => {
      test('should log errors and emit events', () => {
        // Arrange
        const error = new Error('Test error');
        const context = 'task creation';

        // Act
        app.handleError(error, context);

        // Assert
        expect(mockDebugLog.error).toHaveBeenCalledWith(`âŒ Error in ${context}:`, error);
        expect(mockEventBus.emit).toHaveBeenCalledWith('app:error', { error, context });
      });

      test('should show user-friendly error messages', () => {
        // Arrange
        const error = new Error('Storage quota exceeded');
        error.name = 'QuotaExceededError';

        // Act
        app.handleError(error, 'data save');

        // Assert
        expect(mockDomManager.showModal).toHaveBeenCalledWith(
          'Storage Full',
          expect.stringContaining('storage')
        );
      });
    });

    describe('validateEnvironment', () => {
      test('should validate browser capabilities', () => {
        // Mock missing localStorage
        delete global.localStorage;

        const isValid = app.validateEnvironment();

        expect(isValid).toBe(false);
        expect(mockDebugLog.error).toHaveBeenCalledWith(
          'âŒ localStorage not available'
        );
      });
    });
  });

  describe('Performance Monitoring Methods', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('measurePerformance', () => {
      test('should measure operation performance', async () => {
        // Arrange
        const mockOperation = jest.fn().mockResolvedValue('result');

        // Act
        const result = await app.measurePerformance('test-operation', mockOperation);

        // Assert
        expect(result).toBe('result');
        expect(mockDebugLog.info).toHaveBeenCalledWith(
          'â±ï¸ test-operation completed in',
          expect.any(Number),
          'ms'
        );
      });
    });

    describe('getPerformanceMetrics', () => {
      test('should return performance metrics', () => {
        // Act
        const metrics = app.getPerformanceMetrics();

        // Assert
        expect(metrics).toEqual({
          renderTime: expect.any(Number),
          saveTime: expect.any(Number),
          loadTime: expect.any(Number),
          memoryUsage: expect.any(Object)
        });
      });
    });
  });

  describe('Cleanup and Disposal', () => {
    let app;

    beforeEach(async () => {
      const { default: CascadeApp } = await import('scripts/modules/main.js');
      app = new CascadeApp();
      await app.init();
    });

    describe('destroy', () => {
      test('should clean up resources and event listeners', () => {
        // Act
        app.destroy();

        // Assert
        expect(mockEventBus.off).toHaveBeenCalled();
        expect(mockDomManager.removeEventListener).toBeDefined();
        expect(mockDebugLog.info).toHaveBeenCalledWith('ðŸ§¹ App destroyed and cleaned up');
      });
    });

    describe('cleanup', () => {
      test('should perform memory cleanup', () => {
        // Act
        app.cleanup();

        // Assert
        expect(mockAppState.clearHistory).toHaveBeenCalled();
        expect(mockEventBus.clearEmittedEvents).toHaveBeenCalled();
      });
    });
  });
});